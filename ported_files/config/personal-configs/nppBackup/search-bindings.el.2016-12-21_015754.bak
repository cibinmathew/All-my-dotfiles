; http://www.cibinmathew.com
; github.com/cibinmathew

; https://www.emacswiki.org/emacs/SearchAtPoint

; If swiper is used, the following key bindings can be defined to simulate “*” in Vim with a better interface:
  (define-key evil-normal-state-map (kbd "*")
    (lambda () (interactive) (swiper (format "\\<%s\\>" (thing-at-point 'symbol)))))
  (define-key evil-normal-state-map (kbd "#")
    (lambda () (interactive) (swiper (format "\\<%s\\>" (thing-at-point 'word)))))
	


; Extending swiper
; With swiper, the following key bindings can be defined to insert the current symbol/word at point to the swiper minibuffer:
(define-key swiper-map (kbd "C-.")
  (lambda () (interactive) (insert (format "\\<%s\\>" (with-ivy-window (thing-at-point 'symbol))))))
(define-key swiper-map (kbd "M-.")
  (lambda () (interactive) (insert (format "\\<%s\\>" (with-ivy-window (thing-at-point 'word))))))	
; (global-set-key "\C-s" 'my-search-method-according-to-numlines)
(global-set-key "\C-s" 'ora-swiper)	
(global-set-key "\C-s" 
	(swiper (format "\\<%s\\>" (thing-at-point 'word))))	

;; Use regex searches by default.
; (global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "\C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)


;; Activate occur easily inside isearch
(define-key isearch-mode-map (kbd "C-o")
  (lambda () (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))

	  
;; make isearch treat space dash underscore newline as same
(setq search-whitespace-regexp "[-_ \n]")
; put isearch-dabbrev.el somewhere in your load-path and add these lines to your .emacs:

(eval-after-load "isearch"
  '(progn
     (require 'isearch-dabbrev)
     (define-key isearch-mode-map (kbd "<tab>") 'isearch-dabbrev-expand)))
	
	
; http://karl-voit.at/2016/04/09/chosing-emacs-search-method/
 (defun my-search-method-according-to-numlines ()
    "Determines the number of lines of current buffer and chooses a search method accordingly"
    (interactive)
    (if (< (count-lines (point-min) (point-max)) 20000)
        (swiper)
      (isearch-forward)
      )
    )
(defun ora-swiper ()
  (interactive)
  (if (and (buffer-file-name)
           (not (ignore-errors
                  (file-remote-p (buffer-file-name))))
           (if (eq major-mode 'org-mode)
               (> (buffer-size) 60000)
             (> (buffer-size) 300000)))
      (progn
        (save-buffer)
        (counsel-grep))
    ; (swiper--ivy (swiper--candidates))
	(swiper (format "\\<%s\\>" (thing-at-point 'word)))
	))

	
	
; (defun joe-duckduckgo-search (browser)
(defun joe-duckduckgo-search ()
  "Search DuckDuckGo from Emacs."
  ; (interactive)
  (setq myWord
	(if (region-active-p)
	(buffer-substring-no-properties (region-beginning) (region-end))
	(thing-at-point 'symbol)))
	


  
	
  (let ((search
        (concat "https://google.com/?q="
                (read-from-minibuffer "sDuckDuckGo: " myWord))))
				(message "%s" myWord)
    ; (if browser
        (browse-url search)
      (browse-web search)
	  ;)
	  ))
	  
	  
	  ; Enable highlight-symbol-mode (usually done conditionally depending on major mode, as in this example), and set highlight-symbol-on-navigation-p.

  (add-hook 'prog-mode-hook (lambda () (highlight-symbol-mode)))
  (setq highlight-symbol-on-navigation-p t)
  (global-set-key [f3] 'highlight-symbol-next)
  (global-set-key [(shift f3)] 'highlight-symbol-prev)